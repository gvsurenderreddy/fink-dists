diff -uNr mono-1.2.6/configure mono-1.2.6-new/configure
--- mono-1.2.6/configure	2007-11-16 17:03:27.000000000 -0500
+++ mono-1.2.6-new/configure	2007-11-29 16:19:10.000000000 -0500
@@ -3034,7 +3034,7 @@
 		;;
 	*-*-darwin*)
 		platform_win32=no
-		CPPFLAGS="$CPPFLAGS -no-cpp-precomp -D_THREAD_SAFE -DGC_MACOSX_THREADS -DPLATFORM_MACOSX -DUSE_MMAP -DUSE_MUNMAP"
+		CPPFLAGS="$CPPFLAGS -D_THREAD_SAFE -DGC_MACOSX_THREADS -DPLATFORM_MACOSX -DUSE_MMAP -DUSE_MUNMAP"
 		CPPFLAGS="$CPPFLAGS -DGetCurrentProcess=MonoGetCurrentProcess -DGetCurrentThread=MonoGetCurrentThread -DCreateEvent=MonoCreateEvent"
 		libmono_cflags="-D_THREAD_SAFE"
 		LDFLAGS="$LDFLAGS -pthread"
@@ -37379,11 +37379,11 @@
 case "$host" in
      *-*-darwin*)
 	libsuffix=".dylib"
-	LIBC="libc.dylib"
-	INTL="libintl.dylib"
-	SQLITE="libsqlite.0.dylib"
-	SQLITE3="libsqlite3.0.dylib"
-	X11="libX11.dylib"
+	LIBC="/usr/lib/libSystem.dylib"
+	INTL="@FINKPREFIX@/lib/libintl.dylib"
+	SQLITE="@FINKPREFIX@/lib/libsqlite.0.dylib"
+	SQLITE3="@FINKPREFIX@/lib/libsqlite3.0.dylib"
+	X11="/usr/X11R6/lib/libX11.6.dylib"
 	;;
      *-*-*netbsd*)
 	LIBC="libc.so.12"
diff -uNr mono-1.2.6/data/config.in mono-1.2.6-new/data/config.in
--- mono-1.2.6/data/config.in	2007-11-08 17:07:46.000000000 -0500
+++ mono-1.2.6-new/data/config.in	2007-11-29 16:21:21.000000000 -0500
@@ -3,18 +3,18 @@
 	<dllmap dll="libc" target="@LIBC@" os="!windows"/>
 	<dllmap dll="intl" target="@INTL@" os="!windows"/>
 	<dllmap dll="libintl" target="@INTL@" os="!windows"/>
-	<dllmap dll="i:libxslt.dll" target="libxslt@libsuffix@" os="!windows"/>
-	<dllmap dll="i:odbc32.dll" target="libodbc@libsuffix@" os="!windows"/>
-	<dllmap dll="i:odbc32.dll" target="libiodbc.dylib" os="osx"/>
-	<dllmap dll="oci" target="libclntsh@libsuffix@" os="!windows"/>
-	<dllmap dll="db2cli" target="libdb2_36@libsuffix@" os="!windows"/>
-	<dllmap dll="MonoPosixHelper" target="libMonoPosixHelper@libsuffix@" os="!windows" />
+	<dllmap dll="i:libxslt.dll" target="@FINKPREFIX@/lib/libxslt.1@libsuffix@" os="!windows"/>
+	<dllmap dll="i:odbc32.dll" target="@FINKPREFIX@/lib/libodbc.1@libsuffix@" os="!windows"/>
+	<dllmap dll="i:odbc32.dll" target="/usr/lib/libiodbc.2.dylib" os="osx"/>
+	<dllmap dll="oci" target="@FINKPREFIX@/lib/libclntsh@libsuffix@" os="!windows"/>
+	<dllmap dll="db2cli" target="@FINKPREFIX@/lib/libdb2_36@libsuffix@" os="!windows"/>
+	<dllmap dll="MonoPosixHelper" target="@FINKPREFIX@/lib/libMonoPosixHelper@libsuffix@" os="!windows" />
 	<dllmap dll="i:msvcrt" target="@LIBC@" os="!windows"/>
 	<dllmap dll="i:msvcrt.dll" target="@LIBC@" os="!windows"/>
 	<dllmap dll="sqlite" target="@SQLITE@" os="!windows"/>
 	<dllmap dll="sqlite3" target="@SQLITE3@" os="!windows"/>
 	<dllmap dll="libX11" target="@X11@" os="!windows" />
-	<dllmap dll="libcairo-2.dll" target="libcairo.so.2" os="!windows"/>
+	<dllmap dll="libcairo-2.dll" target="@FINKPREFIX@/lib/libcairo.2.dylib" os="!windows"/>
 	<dllmap dll="i:kernel32.dll">
 		<dllentry dll="__Internal" name="CopyMemory" target="mono_win32_compat_CopyMemory"/>
 		<dllentry dll="__Internal" name="FillMemory" target="mono_win32_compat_FillMemory"/>
diff -uNr mono-1.2.6/libgc/darwin_stop_world.c mono-1.2.6-new/libgc/darwin_stop_world.c
--- mono-1.2.6/libgc/darwin_stop_world.c	2007-11-08 17:07:02.000000000 -0500
+++ mono-1.2.6-new/libgc/darwin_stop_world.c	2007-11-29 17:38:30.000000000 -0500
@@ -1,5 +1,7 @@
 #include "private/pthread_support.h"
 
+/* This probably needs more porting work to ppc64. */
+
 # if defined(GC_DARWIN_THREADS)
 
 /* From "Inside Mac OS X - Mach-O Runtime Architecture" published by Apple
@@ -8,7 +10,7 @@
    be allocated, is called the red zone. This area as shown in Figure 3-2 may
    be used for any purpose as long as a new stack frame does not need to be
    added to the stack."
-   
+
    Page 50: "If a leaf procedure's red zone usage would exceed 224 bytes, then
    it must set up a stack frame just like routines that call other routines."
 */
@@ -28,15 +30,16 @@
   unsigned long	savedRTOC;
 } StackFrame;
 
-unsigned long FindTopOfStack(unsigned int stack_start) {
+unsigned long FindTopOfStack(unsigned int stack_start)
+{
   StackFrame	*frame;
-  
+
   if (stack_start == 0) {
 # ifdef POWERPC
 #   if CPP_WORDSZ == 32
       __asm__ volatile("lwz	%0,0(r1)" : "=r" (frame));
 #   else
-      __asm__ volatile("ldz	%0,0(r1)" : "=r" (frame));
+      __asm__ volatile("ld	%0,0(r1)" : "=r" (frame));
 #   endif
 # endif
   } else {
@@ -44,356 +47,310 @@
   }
 
 # ifdef DEBUG_THREADS
-    /* GC_printf1("FindTopOfStack start at sp = %p\n", frame); */
+    /* GC_printf("FindTopOfStack start at sp = %p\n", frame); */
 # endif
   do {
-    if (frame->savedSP == 0) break;
-    		/* if there are no more stack frames, stop */
+    if (frame->savedSP == 0)
+      break;
+    /* if there are no more stack frames, stop */
 
     frame = (StackFrame*)frame->savedSP;
 
     /* we do these next two checks after going to the next frame
        because the LR for the first stack frame in the loop
        is not set up on purpose, so we shouldn't check it. */
-    if ((frame->savedLR & ~3) == 0) break; /* if the next LR is bogus, stop */
-    if ((~(frame->savedLR) & ~3) == 0) break; /* ditto */
-  } while (1); 
+    if ((frame->savedLR & ~3) == 0)
+      break; /* if the next LR is bogus, stop */
+    if ((~(frame->savedLR) & ~3) == 0)
+      break; /* ditto */
+  } while (1);
 
 # ifdef DEBUG_THREADS
-    /* GC_printf1("FindTopOfStack finish at sp = %p\n", frame); */
+    /* GC_printf("FindTopOfStack finish at sp = %p\n", frame); */
 # endif
 
   return (unsigned long)frame;
-}	
+}
 
 #ifdef DARWIN_DONT_PARSE_STACK
-void GC_push_all_stacks() {
+void GC_push_all_stacks()
+{
   int i;
   kern_return_t r;
   GC_thread p;
   pthread_t me;
   ptr_t lo, hi;
-#if defined(POWERPC)
-  ppc_thread_state_t state;
-  mach_msg_type_number_t thread_state_count = PPC_THREAD_STATE_COUNT;
-#elif defined(I386)
-  i386_thread_state_t state;
-  mach_msg_type_number_t thread_state_count = i386_THREAD_STATE_COUNT;
-#else
-# error FIXME for non-x86 || ppc architectures
-  mach_msg_type_number_t thread_state_count = MACHINE_THREAD_STATE_COUNT;
-#endif
-  
+  GC_THREAD_STATE_T state;
+  /* MACHINE_THREAD_STATE_COUNT doesn't seem to be defined everywhere.	*/
+  /* Hence we use our own version.					*/
+  mach_msg_type_number_t thread_state_count = GC_MACH_THREAD_STATE_COUNT;
+
   me = pthread_self();
-  if (!GC_thr_initialized) GC_thr_init();
-  
-  for(i=0;i<THREAD_TABLE_SZ;i++) {
-    for(p=GC_threads[i];p!=0;p=p->next) {
-      if(p -> flags & FINISHED) continue;
-      if(pthread_equal(p->id,me)) {
+  if (!GC_thr_initialized)
+    GC_thr_init();
+
+  for(i = 0; i < THREAD_TABLE_SZ; i++) {
+    for(p = GC_threads[i]; p != 0; p = p->next) {
+      if(p->flags & FINISHED) continue;
+      if(pthread_equal(p->id, me)) {
 	lo = GC_approx_sp();
       } else {
 	/* Get the thread state (registers, etc) */
-	r = thread_get_state(
-			     p->stop_info.mach_thread,
-			     GC_MACH_THREAD_STATE_FLAVOR,
-			     (natural_t*)&state,
-			     &thread_state_count);
-	if(r != KERN_SUCCESS) ABORT("thread_get_state failed");
-	
-#if defined(I386)
-#if defined(_STRUCT_X86_EXCEPTION_STATE32)
-	lo = state.__esp;
-
-	GC_push_one(state.__eax); 
-	GC_push_one(state.__ebx); 
-	GC_push_one(state.__ecx); 
-	GC_push_one(state.__edx); 
-	GC_push_one(state.__edi); 
-	GC_push_one(state.__esi); 
-	GC_push_one(state.__ebp); 
-#else
-	lo = state.esp;
-
-	GC_push_one(state.eax); 
-	GC_push_one(state.ebx); 
-	GC_push_one(state.ecx); 
-	GC_push_one(state.edx); 
-	GC_push_one(state.edi); 
-	GC_push_one(state.esi); 
-	GC_push_one(state.ebp); 
-#endif
-#elif defined(POWERPC)
-#if defined(_STRUCT_PPC_EXCEPTION_STATE)
-	lo = (void*)(state.__r1 - PPC_RED_ZONE_SIZE);
-        
-	GC_push_one(state.__r0); 
-	GC_push_one(state.__r2); 
-	GC_push_one(state.__r3); 
-	GC_push_one(state.__r4); 
-	GC_push_one(state.__r5); 
-	GC_push_one(state.__r6); 
-	GC_push_one(state.__r7); 
-	GC_push_one(state.__r8); 
-	GC_push_one(state.__r9); 
-	GC_push_one(state.__r10); 
-	GC_push_one(state.__r11); 
-	GC_push_one(state.__r12); 
-	GC_push_one(state.__r13); 
-	GC_push_one(state.__r14); 
-	GC_push_one(state.__r15); 
-	GC_push_one(state.__r16); 
-	GC_push_one(state.__r17); 
-	GC_push_one(state.__r18); 
-	GC_push_one(state.__r19); 
-	GC_push_one(state.__r20); 
-	GC_push_one(state.__r21); 
-	GC_push_one(state.__r22); 
-	GC_push_one(state.__r23); 
-	GC_push_one(state.__r24); 
-	GC_push_one(state.__r25); 
-	GC_push_one(state.__r26); 
-	GC_push_one(state.__r27); 
-	GC_push_one(state.__r28); 
-	GC_push_one(state.__r29); 
-	GC_push_one(state.__r30); 
-	GC_push_one(state.__r31);
-#else
-	lo = (void*)(state.r1 - PPC_RED_ZONE_SIZE);
-        
-	GC_push_one(state.r0); 
-	GC_push_one(state.r2); 
-	GC_push_one(state.r3); 
-	GC_push_one(state.r4); 
-	GC_push_one(state.r5); 
-	GC_push_one(state.r6); 
-	GC_push_one(state.r7); 
-	GC_push_one(state.r8); 
-	GC_push_one(state.r9); 
-	GC_push_one(state.r10); 
-	GC_push_one(state.r11); 
-	GC_push_one(state.r12); 
-	GC_push_one(state.r13); 
-	GC_push_one(state.r14); 
-	GC_push_one(state.r15); 
-	GC_push_one(state.r16); 
-	GC_push_one(state.r17); 
-	GC_push_one(state.r18); 
-	GC_push_one(state.r19); 
-	GC_push_one(state.r20); 
-	GC_push_one(state.r21); 
-	GC_push_one(state.r22); 
-	GC_push_one(state.r23); 
-	GC_push_one(state.r24); 
-	GC_push_one(state.r25); 
-	GC_push_one(state.r26); 
-	GC_push_one(state.r27); 
-	GC_push_one(state.r28); 
-	GC_push_one(state.r29); 
-	GC_push_one(state.r30); 
-	GC_push_one(state.r31);
-#endif
-#else
-# error FIXME for non-x86 || ppc architectures
-#endif
+	r = thread_get_state(p->stop_info.mach_thread, GC_MACH_THREAD_STATE,
+			     (natural_t*)&state, &thread_state_count);
+
+#       ifdef DEBUG_THREADS
+	  GC_printf("thread_get_state return value = %d\n", r);
+#	endif
+
+	if(r != KERN_SUCCESS)
+	  ABORT("thread_get_state failed");
+
+#       if defined(I386)
+	  lo = (void*)state . THREAD_FLD (esp);
+	  GC_push_one(state . THREAD_FLD (eax));
+	  GC_push_one(state . THREAD_FLD (ebx));
+	  GC_push_one(state . THREAD_FLD (ecx));
+	  GC_push_one(state . THREAD_FLD (edx));
+	  GC_push_one(state . THREAD_FLD (edi));
+	  GC_push_one(state . THREAD_FLD (esi));
+	  GC_push_one(state . THREAD_FLD (ebp));
+
+#       elif defined(X86_64)
+	  lo = (void*)state . THREAD_FLD (rsp);
+	  GC_push_one(state . THREAD_FLD (rax));
+	  GC_push_one(state . THREAD_FLD (rbx));
+	  GC_push_one(state . THREAD_FLD (rcx));
+	  GC_push_one(state . THREAD_FLD (rdx));
+	  GC_push_one(state . THREAD_FLD (rdi));
+	  GC_push_one(state . THREAD_FLD (rsi));
+	  GC_push_one(state . THREAD_FLD (rbp));
+	  GC_push_one(state . THREAD_FLD (rsp));
+	  GC_push_one(state . THREAD_FLD (r8));
+	  GC_push_one(state . THREAD_FLD (r9));
+	  GC_push_one(state . THREAD_FLD (r10));
+	  GC_push_one(state . THREAD_FLD (r11));
+	  GC_push_one(state . THREAD_FLD (r12));
+	  GC_push_one(state . THREAD_FLD (r13));
+	  GC_push_one(state . THREAD_FLD (r14));
+	  GC_push_one(state . THREAD_FLD (r15));
+	  GC_push_one(state . THREAD_FLD (rip));
+	  GC_push_one(state . THREAD_FLD (rflags));
+	  GC_push_one(state . THREAD_FLD (cs));
+	  GC_push_one(state . THREAD_FLD (fs));
+	  GC_push_one(state . THREAD_FLD (gs));
+
+#       elif defined(POWERPC)
+	  lo = (void*)(state . THREAD_FLD (r1) - PPC_RED_ZONE_SIZE);
+
+	  GC_push_one(state . THREAD_FLD (r0));
+	  GC_push_one(state . THREAD_FLD (r2));
+	  GC_push_one(state . THREAD_FLD (r3));
+	  GC_push_one(state . THREAD_FLD (r4));
+	  GC_push_one(state . THREAD_FLD (r5));
+	  GC_push_one(state . THREAD_FLD (r6));
+	  GC_push_one(state . THREAD_FLD (r7));
+	  GC_push_one(state . THREAD_FLD (r8));
+	  GC_push_one(state . THREAD_FLD (r9));
+	  GC_push_one(state . THREAD_FLD (r10));
+	  GC_push_one(state . THREAD_FLD (r11));
+	  GC_push_one(state . THREAD_FLD (r12));
+	  GC_push_one(state . THREAD_FLD (r13));
+	  GC_push_one(state . THREAD_FLD (r14));
+	  GC_push_one(state . THREAD_FLD (r15));
+	  GC_push_one(state . THREAD_FLD (r16));
+	  GC_push_one(state . THREAD_FLD (r17));
+	  GC_push_one(state . THREAD_FLD (r18));
+	  GC_push_one(state . THREAD_FLD (r19));
+	  GC_push_one(state . THREAD_FLD (r20));
+	  GC_push_one(state . THREAD_FLD (r21));
+	  GC_push_one(state . THREAD_FLD (r22));
+	  GC_push_one(state . THREAD_FLD (r23));
+	  GC_push_one(state . THREAD_FLD (r24));
+	  GC_push_one(state . THREAD_FLD (r25));
+	  GC_push_one(state . THREAD_FLD (r26));
+	  GC_push_one(state . THREAD_FLD (r27));
+	  GC_push_one(state . THREAD_FLD (r28));
+	  GC_push_one(state . THREAD_FLD (r29));
+	  GC_push_one(state . THREAD_FLD (r30));
+	  GC_push_one(state . THREAD_FLD (r31));
+#	else
+#	  error FIXME for non-x86 || ppc architectures
+#	endif
       } /* p != me */
       if(p->flags & MAIN_THREAD)
 	hi = GC_stackbottom;
       else
 	hi = p->stack_end;
-#if DEBUG_THREADS
-      GC_printf3("Darwin: Stack for thread 0x%lx = [%lx,%lx)\n",
-		 (unsigned long) p -> id,
-		 (unsigned long) lo,
-		 (unsigned long) hi
-		 );
-#endif
-      GC_push_all_stack(lo,hi);
+#     if DEBUG_THREADS
+        GC_printf("Darwin: Stack for thread 0x%lx = [%lx,%lx)\n",
+		  (unsigned long) p -> id, (unsigned long) lo,
+		  (unsigned long) hi);
+#     endif
+      GC_push_all_stack(lo, hi);
     } /* for(p=GC_threads[i]...) */
   } /* for(i=0;i<THREAD_TABLE_SZ...) */
 }
 
 #else /* !DARWIN_DONT_PARSE_STACK; Use FindTopOfStack() */
 
-void GC_push_all_stacks() {
-    int i;
-	task_t my_task;
-    kern_return_t r;
-    mach_port_t me;
-    ptr_t lo, hi;
-    thread_act_array_t act_list = 0;
-    mach_msg_type_number_t listcount = 0;
-
-    me = mach_thread_self();
-    if (!GC_thr_initialized) GC_thr_init();
-    
-	my_task = current_task();
-    r = task_threads(my_task, &act_list, &listcount);
-    if(r != KERN_SUCCESS) ABORT("task_threads failed");
-    for(i = 0; i < listcount; i++) {
-      thread_act_t thread = act_list[i];
-      if (thread == me) {
-	lo = GC_approx_sp();
-	hi = (ptr_t)FindTopOfStack(0);
-      } else {
+void GC_push_all_stacks()
+{
+  unsigned int i;
+  task_t my_task;
+  kern_return_t r;
+  mach_port_t me;
+  ptr_t lo, hi;
+  thread_act_array_t act_list = 0;
+  mach_msg_type_number_t listcount = 0;
+
+  me = mach_thread_self();
+  if (!GC_thr_initialized)
+    GC_thr_init();
+
+  my_task = current_task();
+  r = task_threads(my_task, &act_list, &listcount);
+  if(r != KERN_SUCCESS)
+    ABORT("task_threads failed");
+  for(i = 0; i < listcount; i++) {
+    thread_act_t thread = act_list[i];
+    if (thread == me) {
+      lo = GC_approx_sp();
+      hi = (ptr_t)FindTopOfStack(0);
+    } else {
 #     if defined(POWERPC)
-#      if CPP_WORDSZ == 32
-	ppc_thread_state_t info;
-#      else
-	ppc_thread_state64_t info;
-#      endif
+        GC_THREAD_STATE_T info;
 	mach_msg_type_number_t outCount = THREAD_STATE_MAX;
-	r = thread_get_state(thread, GC_MACH_THREAD_STATE_FLAVOR,
-			     (natural_t *)&info, &outCount);
-	if(r != KERN_SUCCESS) continue;
-
-#if defined(_STRUCT_PPC_EXCEPTION_STATE)
-	lo = (void*)(info.__r1 - PPC_RED_ZONE_SIZE);
-	hi = (ptr_t)FindTopOfStack(info.__r1);
-
-	GC_push_one(info.__r0); 
-	GC_push_one(info.__r2); 
-	GC_push_one(info.__r3); 
-	GC_push_one(info.__r4); 
-	GC_push_one(info.__r5); 
-	GC_push_one(info.__r6); 
-	GC_push_one(info.__r7); 
-	GC_push_one(info.__r8); 
-	GC_push_one(info.__r9); 
-	GC_push_one(info.__r10); 
-	GC_push_one(info.__r11); 
-	GC_push_one(info.__r12); 
-	GC_push_one(info.__r13); 
-	GC_push_one(info.__r14); 
-	GC_push_one(info.__r15); 
-	GC_push_one(info.__r16); 
-	GC_push_one(info.__r17); 
-	GC_push_one(info.__r18); 
-	GC_push_one(info.__r19); 
-	GC_push_one(info.__r20); 
-	GC_push_one(info.__r21); 
-	GC_push_one(info.__r22); 
-	GC_push_one(info.__r23); 
-	GC_push_one(info.__r24); 
-	GC_push_one(info.__r25); 
-	GC_push_one(info.__r26); 
-	GC_push_one(info.__r27); 
-	GC_push_one(info.__r28); 
-	GC_push_one(info.__r29); 
-	GC_push_one(info.__r30); 
-	GC_push_one(info.__r31);
-#else
-	lo = (void*)(info.r1 - PPC_RED_ZONE_SIZE);
-	hi = (ptr_t)FindTopOfStack(info.r1);
-
-	GC_push_one(info.r0); 
-	GC_push_one(info.r2); 
-	GC_push_one(info.r3); 
-	GC_push_one(info.r4); 
-	GC_push_one(info.r5); 
-	GC_push_one(info.r6); 
-	GC_push_one(info.r7); 
-	GC_push_one(info.r8); 
-	GC_push_one(info.r9); 
-	GC_push_one(info.r10); 
-	GC_push_one(info.r11); 
-	GC_push_one(info.r12); 
-	GC_push_one(info.r13); 
-	GC_push_one(info.r14); 
-	GC_push_one(info.r15); 
-	GC_push_one(info.r16); 
-	GC_push_one(info.r17); 
-	GC_push_one(info.r18); 
-	GC_push_one(info.r19); 
-	GC_push_one(info.r20); 
-	GC_push_one(info.r21); 
-	GC_push_one(info.r22); 
-	GC_push_one(info.r23); 
-	GC_push_one(info.r24); 
-	GC_push_one(info.r25); 
-	GC_push_one(info.r26); 
-	GC_push_one(info.r27); 
-	GC_push_one(info.r28); 
-	GC_push_one(info.r29); 
-	GC_push_one(info.r30); 
-	GC_push_one(info.r31);
-#endif
-#      else
+	r = thread_get_state(thread, GC_MACH_THREAD_STATE, (natural_t *)&info,
+			     &outCount);
+	if(r != KERN_SUCCESS)
+	  ABORT("task_get_state failed");
+
+	lo = (void*)(info . THREAD_FLD (r1) - PPC_RED_ZONE_SIZE);
+	hi = (ptr_t)FindTopOfStack(info . THREAD_FLD (r1));
+
+	GC_push_one(info . THREAD_FLD (r0));
+	GC_push_one(info . THREAD_FLD (r2));
+	GC_push_one(info . THREAD_FLD (r3));
+	GC_push_one(info . THREAD_FLD (r4));
+	GC_push_one(info . THREAD_FLD (r5));
+	GC_push_one(info . THREAD_FLD (r6));
+	GC_push_one(info . THREAD_FLD (r7));
+	GC_push_one(info . THREAD_FLD (r8));
+	GC_push_one(info . THREAD_FLD (r9));
+	GC_push_one(info . THREAD_FLD (r10));
+	GC_push_one(info . THREAD_FLD (r11));
+	GC_push_one(info . THREAD_FLD (r12));
+	GC_push_one(info . THREAD_FLD (r13));
+	GC_push_one(info . THREAD_FLD (r14));
+	GC_push_one(info . THREAD_FLD (r15));
+	GC_push_one(info . THREAD_FLD (r16));
+	GC_push_one(info . THREAD_FLD (r17));
+	GC_push_one(info . THREAD_FLD (r18));
+	GC_push_one(info . THREAD_FLD (r19));
+	GC_push_one(info . THREAD_FLD (r20));
+	GC_push_one(info . THREAD_FLD (r21));
+	GC_push_one(info . THREAD_FLD (r22));
+	GC_push_one(info . THREAD_FLD (r23));
+	GC_push_one(info . THREAD_FLD (r24));
+	GC_push_one(info . THREAD_FLD (r25));
+	GC_push_one(info . THREAD_FLD (r26));
+	GC_push_one(info . THREAD_FLD (r27));
+	GC_push_one(info . THREAD_FLD (r28));
+	GC_push_one(info . THREAD_FLD (r29));
+	GC_push_one(info . THREAD_FLD (r30));
+	GC_push_one(info . THREAD_FLD (r31));
+
+#     elif defined(I386)
 	/* FIXME: Remove after testing:	*/
 	WARN("This is completely untested and likely will not work\n", 0);
-	i386_thread_state_t info;
+	GC_THREAD_STATE_T info;
 	mach_msg_type_number_t outCount = THREAD_STATE_MAX;
-	r = thread_get_state(thread, GC_MACH_THREAD_STATE_FLAVOR,
-			     (natural_t *)&info, &outCount);
-	if(r != KERN_SUCCESS) continue;
-
-#if defined(_STRUCT_X86_EXCEPTION_STATE32)
-	lo = (void*)info.__esp;
-	hi = (ptr_t)FindTopOfStack(info.__esp);
-
-	GC_push_one(info.__eax); 
-	GC_push_one(info.__ebx); 
-	GC_push_one(info.__ecx); 
-	GC_push_one(info.__edx); 
-	GC_push_one(info.__edi); 
-	GC_push_one(info.__esi); 
-	GC_push_one(info.__ebp);
-	/* GC_push_one(info.__esp);  */
-	GC_push_one(info.__ss); 
-	GC_push_one(info.__eip); 
-	GC_push_one(info.__cs); 
-	GC_push_one(info.__ds); 
-	GC_push_one(info.__es); 
-	GC_push_one(info.__fs); 
-	GC_push_one(info.__gs); 
-#else
-	lo = (void*)info.esp;
-	hi = (ptr_t)FindTopOfStack(info.esp);
-
-	GC_push_one(info.eax); 
-	GC_push_one(info.ebx); 
-	GC_push_one(info.ecx); 
-	GC_push_one(info.edx); 
-	GC_push_one(info.edi); 
-	GC_push_one(info.esi); 
-	GC_push_one(info.ebp);
-	/* GC_push_one(info.esp);  */
-	GC_push_one(info.ss); 
-	GC_push_one(info.eip); 
-	GC_push_one(info.cs); 
-	GC_push_one(info.ds); 
-	GC_push_one(info.es); 
-	GC_push_one(info.fs); 
-	GC_push_one(info.gs); 
-#endif
-#      endif /* !POWERPC */
+	r = thread_get_state(thread, GC_MACH_THREAD_STATE, (natural_t *)&info,
+			     &outCount);
+	if(r != KERN_SUCCESS)
+	  ABORT("task_get_state failed");
+
+	lo = (void*)info . THREAD_FLD (esp);
+	hi = (ptr_t)FindTopOfStack(info . THREAD_FLD (esp));
+
+	GC_push_one(info . THREAD_FLD (eax));
+	GC_push_one(info . THREAD_FLD (ebx));
+	GC_push_one(info . THREAD_FLD (ecx));
+	GC_push_one(info . THREAD_FLD (edx));
+	GC_push_one(info . THREAD_FLD (edi));
+	GC_push_one(info . THREAD_FLD (esi));
+	/* GC_push_one(info . THREAD_FLD (ebp));  */
+	/* GC_push_one(info . THREAD_FLD (esp));  */
+	GC_push_one(info . THREAD_FLD (ss));
+	GC_push_one(info . THREAD_FLD (eip));
+	GC_push_one(info . THREAD_FLD (cs));
+	GC_push_one(info . THREAD_FLD (ds));
+	GC_push_one(info . THREAD_FLD (es));
+	GC_push_one(info . THREAD_FLD (fs));
+	GC_push_one(info . THREAD_FLD (gs));
+
+#     elif defined(X86_64)
+	GC_THREAD_STATE_T info;
+	mach_msg_type_number_t outCount = THREAD_STATE_MAX;
+	r = thread_get_state(thread, GC_MACH_THREAD_STATE, (natural_t *)&info,
+			     &outCount);
+	if(r != KERN_SUCCESS)
+	  ABORT("task_get_state failed");
+
+	lo = (void*)info . THREAD_FLD (rsp);
+	hi = (ptr_t)FindTopOfStack(info . THREAD_FLD (rsp));
+
+	GC_push_one(info . THREAD_FLD (rax));
+	GC_push_one(info . THREAD_FLD (rbx));
+	GC_push_one(info . THREAD_FLD (rcx));
+	GC_push_one(info . THREAD_FLD (rdx));
+	GC_push_one(info . THREAD_FLD (rdi));
+	GC_push_one(info . THREAD_FLD (rsi));
+	GC_push_one(info . THREAD_FLD (rbp));
+	GC_push_one(info . THREAD_FLD (rsp));
+	GC_push_one(info . THREAD_FLD (r8));
+	GC_push_one(info . THREAD_FLD (r9));
+	GC_push_one(info . THREAD_FLD (r10));
+	GC_push_one(info . THREAD_FLD (r11));
+	GC_push_one(info . THREAD_FLD (r12));
+	GC_push_one(info . THREAD_FLD (r13));
+	GC_push_one(info . THREAD_FLD (r14));
+	GC_push_one(info . THREAD_FLD (r15));
+	GC_push_one(info . THREAD_FLD (rip));
+	GC_push_one(info . THREAD_FLD (rflags));
+	GC_push_one(info . THREAD_FLD (cs));
+	GC_push_one(info . THREAD_FLD (fs));
+	GC_push_one(info . THREAD_FLD (gs));
+
+#     else
+#	error FIXME for non-x86 || ppc architectures
+#     endif
       }
 #     if DEBUG_THREADS
-       GC_printf3("Darwin: Stack for thread 0x%lx = [%lx,%lx)\n",
-		  (unsigned long) thread,
-		  (unsigned long) lo,
-		  (unsigned long) hi
-		 );
+        GC_printf("Darwin: Stack for thread 0x%lx = [%p,%p)\n",
+		  (unsigned long) thread, lo, hi);
 #     endif
       GC_push_all_stack(lo, hi);
-	  mach_port_deallocate(my_task, thread);
+      mach_port_deallocate(my_task, thread);
     } /* for(p=GC_threads[i]...) */
-    vm_deallocate(my_task, (vm_address_t)act_list, sizeof(thread_t) * listcount);
-	mach_port_deallocate(my_task, me);
+    vm_deallocate(my_task, (vm_address_t)act_list,
+		  sizeof(thread_t) * listcount);
+    mach_port_deallocate(my_task, me);
 }
 #endif /* !DARWIN_DONT_PARSE_STACK */
 
 static mach_port_t GC_mach_handler_thread;
 static int GC_use_mach_handler_thread = 0;
 
-#define SUSPEND_THREADS_SIZE 2048
-static struct GC_mach_thread GC_mach_threads[SUSPEND_THREADS_SIZE];
+static struct GC_mach_thread GC_mach_threads[THREAD_TABLE_SZ];
 static int GC_mach_threads_count;
 
-void GC_stop_init() {
+void GC_stop_init()
+{
   int i;
 
-  for (i = 0; i < SUSPEND_THREADS_SIZE; i++) {
+  for (i = 0; i < THREAD_TABLE_SZ; i++) {
     GC_mach_threads[i].thread = 0;
     GC_mach_threads[i].already_suspended = 0;
   }
@@ -401,8 +358,9 @@
 }
 
 /* returns true if there's a thread in act_list that wasn't in old_list */
-int GC_suspend_thread_list(thread_act_array_t act_list, int count, 
-			   thread_act_array_t old_list, int old_count) {
+int GC_suspend_thread_list(thread_act_array_t act_list, int count,
+			   thread_act_array_t old_list, int old_count)
+{
   mach_port_t my_thread = mach_thread_self();
   int i, j;
 
@@ -410,8 +368,8 @@
 
   for(i = 0; i < count; i++) {
     thread_act_t thread = act_list[i];
-#   if DEBUG_THREADS 
-      GC_printf1("Attempting to suspend thread %p\n", thread);
+#   if DEBUG_THREADS
+      GC_printf("Attempting to suspend thread %p\n", thread);
 #   endif
     /* find the current thread in the old list */
     int found = 0;
@@ -428,53 +386,55 @@
       /* default is not suspended */
       GC_mach_threads[GC_mach_threads_count].already_suspended = 0;
       changed = 1;
-    }      
+    }
 
-    if (thread != my_thread &&
-	(!GC_use_mach_handler_thread
-	 || (GC_use_mach_handler_thread
-	     && GC_mach_handler_thread != thread))) {
+    if (thread != my_thread
+	&& (!GC_use_mach_handler_thread
+	    || (GC_use_mach_handler_thread
+		&& GC_mach_handler_thread != thread))) {
       struct thread_basic_info info;
       mach_msg_type_number_t outCount = THREAD_INFO_MAX;
       kern_return_t kern_result = thread_info(thread, THREAD_BASIC_INFO,
 				(thread_info_t)&info, &outCount);
       if(kern_result != KERN_SUCCESS) {
-	/* the thread may have quit since the thread_threads () call 
+	/* the thread may have quit since the thread_threads () call
 	 * we mark already_suspended so it's not dealt with anymore later
 	 */
-        if (!found) {
+	if (!found) {
 	  GC_mach_threads[GC_mach_threads_count].already_suspended = TRUE;
-    	  GC_mach_threads_count++;
+	  GC_mach_threads_count++;
 	}
 	continue;
       }
 #     if DEBUG_THREADS
-        GC_printf2("Thread state for 0x%lx = %d\n", thread, info.run_state);
+        GC_printf("Thread state for 0x%lx = %d\n", (unsigned long)thread,
+		  info.run_state);
 #     endif
       if (!found) {
-	GC_mach_threads[GC_mach_threads_count].already_suspended = info.suspend_count;
+	GC_mach_threads[GC_mach_threads_count].already_suspended
+	  = info.suspend_count;
       }
-      if (info.suspend_count) continue;
-      
+      if (info.suspend_count)
+	continue;
+
 #     if DEBUG_THREADS
-        GC_printf1("Suspending 0x%lx\n", thread);
+        GC_printf("Suspending 0x%lx\n", (unsigned long)thread);
 #     endif
       /* Suspend the thread */
       kern_result = thread_suspend(thread);
       if(kern_result != KERN_SUCCESS) {
-	/* the thread may have quit since the thread_threads () call 
+	/* the thread may have quit since the thread_threads () call
 	 * we mark already_suspended so it's not dealt with anymore later
 	 */
-        if (!found) {
+	if (!found) {
 	  GC_mach_threads[GC_mach_threads_count].already_suspended = TRUE;
-    	  GC_mach_threads_count++;
+	  GC_mach_threads_count++;
 	}
 	continue;
       }
-    } 
+    }
     if (!found) GC_mach_threads_count++;
   }
-  
   mach_port_deallocate(current_task(), my_thread);
   return changed;
 }
@@ -483,21 +443,21 @@
 /* Caller holds allocation lock.	*/
 void GC_stop_world()
 {
-  int i, changes;
-    GC_thread p;
-	task_t my_task = current_task();
+    unsigned int i, changes;
+    task_t my_task = current_task();
     mach_port_t my_thread = mach_thread_self();
     kern_return_t kern_result;
     thread_act_array_t act_list, prev_list;
     mach_msg_type_number_t listcount, prevcount;
-    
+
 #   if DEBUG_THREADS
-      GC_printf1("Stopping the world from 0x%lx\n", mach_thread_self());
+      GC_printf("Stopping the world from 0x%lx\n",
+		(unsigned long)mach_thread_self());
 #   endif
 
     /* clear out the mach threads list table */
-    GC_stop_init(); 
-       
+    GC_stop_init();
+
     /* Make sure all free list construction has stopped before we start. */
     /* No new construction can start, since free list construction is	*/
     /* required to acquire and release the GC lock before it starts,	*/
@@ -508,59 +468,59 @@
       /* We should have previously waited for it to become zero. */
 #   endif /* PARALLEL_MARK */
 
-      /* Loop stopping threads until you have gone over the whole list
-	 twice without a new one appearing. thread_create() won't
-	 return (and thus the thread stop) until the new thread
-	 exists, so there is no window whereby you could stop a
-	 thread, recognise it is stopped, but then have a new thread
-	 it created before stopping show up later.
-      */
-      
-      changes = 1;
-      prev_list = NULL;
-      prevcount = 0;
-      do {
-	int result;		  
-	kern_result = task_threads(my_task, &act_list, &listcount);
-	
-	if(kern_result == KERN_SUCCESS) {	
-		result = GC_suspend_thread_list(act_list, listcount,
-										prev_list, prevcount);
-		changes = result;
-		
-		if(prev_list != NULL) {
-			for(i = 0; i < prevcount; i++)
-				mach_port_deallocate(my_task, prev_list[i]);
-			
-			vm_deallocate(my_task, (vm_address_t)prev_list, sizeof(thread_t) * prevcount);
-		}
-		
-		prev_list = act_list;
-		prevcount = listcount;
-	}		
-      } while (changes);
-     
-	  for(i = 0; i < listcount; i++)
-		  mach_port_deallocate(my_task, act_list[i]);
-	  
-	  vm_deallocate(my_task, (vm_address_t)act_list, sizeof(thread_t) * listcount);
-	  
- 
+    /* Loop stopping threads until you have gone over the whole list
+       twice without a new one appearing. thread_create() won't
+       return (and thus the thread stop) until the new thread
+       exists, so there is no window whereby you could stop a
+       thread, recognise it is stopped, but then have a new thread
+       it created before stopping show up later.
+    */
+
+    changes = 1;
+    prev_list = NULL;
+    prevcount = 0;
+    do {
+      int result;
+      kern_result = task_threads(my_task, &act_list, &listcount);
+
+      if(kern_result == KERN_SUCCESS) {
+	result = GC_suspend_thread_list(act_list, listcount, prev_list,
+					prevcount);
+	changes = result;
+
+	if(prev_list != NULL) {
+	  for(i = 0; i < prevcount; i++)
+	    mach_port_deallocate(my_task, prev_list[i]);
+
+	  vm_deallocate(my_task, (vm_address_t)prev_list,
+			sizeof(thread_t) * prevcount);
+	}
+	prev_list = act_list;
+	prevcount = listcount;
+      }
+    } while (changes);
+    GC_ASSERT(prev_list != 0);
+    for(i = 0; i < prevcount; i++)
+      mach_port_deallocate(my_task, prev_list[i]);
+
+    vm_deallocate(my_task, (vm_address_t)act_list,
+		  sizeof(thread_t) * listcount);
+
 #   ifdef MPROTECT_VDB
       if(GC_incremental) {
-        extern void GC_mprotect_stop();
-        GC_mprotect_stop();
+	extern void GC_mprotect_stop();
+	GC_mprotect_stop();
       }
 #   endif
-    
+
 #   ifdef PARALLEL_MARK
       GC_release_mark_lock();
 #   endif
-    #if DEBUG_THREADS
-      GC_printf1("World stopped from 0x%lx\n", my_thread);
-    #endif
-	  
-	  mach_port_deallocate(my_task, my_thread);
+#   if DEBUG_THREADS
+      GC_printf("World stopped from 0x%lx\n", (unsigned long)my_thread);
+#   endif
+
+    mach_port_deallocate(my_task, my_thread);
 }
 
 /* Caller holds allocation lock, and has held it continuously since	*/
@@ -569,65 +529,69 @@
 {
   task_t my_task = current_task();
   mach_port_t my_thread = mach_thread_self();
-  int i, j;
-  GC_thread p;
+  unsigned int i;
+  int j;
   kern_return_t kern_result;
   thread_act_array_t act_list;
   mach_msg_type_number_t listcount;
   struct thread_basic_info info;
   mach_msg_type_number_t outCount = THREAD_INFO_MAX;
-  
+
 #   if DEBUG_THREADS
-      GC_printf0("World starting\n");
+      GC_printf("World starting\n");
 #   endif
 
 #   ifdef MPROTECT_VDB
       if(GC_incremental) {
-        extern void GC_mprotect_resume();
-        GC_mprotect_resume();
+	extern void GC_mprotect_resume();
+	GC_mprotect_resume();
       }
 #   endif
 
     kern_result = task_threads(my_task, &act_list, &listcount);
     for(i = 0; i < listcount; i++) {
       thread_act_t thread = act_list[i];
-      if (thread != my_thread &&
-	  (!GC_use_mach_handler_thread ||
-	   (GC_use_mach_handler_thread && GC_mach_handler_thread != thread))) {
+      if (thread != my_thread
+	  && (!GC_use_mach_handler_thread
+	      || (GC_use_mach_handler_thread
+		  && GC_mach_handler_thread != thread))) {
 	for(j = 0; j < GC_mach_threads_count; j++) {
 	  if (thread == GC_mach_threads[j].thread) {
 	    if (GC_mach_threads[j].already_suspended) {
 #             if DEBUG_THREADS
-	        GC_printf1("Not resuming already suspended thread %p\n", thread);
+	        GC_printf("Not resuming already suspended thread %p\n", thread);
 #             endif
 	      continue;
 	    }
 	    kern_result = thread_info(thread, THREAD_BASIC_INFO,
 				      (thread_info_t)&info, &outCount);
-	    if(kern_result != KERN_SUCCESS) continue;
+	    if(kern_result != KERN_SUCCESS)
+	      ABORT("thread_info failed");
 #           if DEBUG_THREADS
-	      GC_printf2("Thread state for 0x%lx = %d\n", thread,
+	      GC_printf("Thread state for 0x%lx = %d\n", (unsigned long)thread,
 			 info.run_state);
-	      GC_printf1("Resuming 0x%lx\n", thread);
+	      GC_printf("Resuming 0x%lx\n", (unsigned long)thread);
 #           endif
 	    /* Resume the thread */
 	    kern_result = thread_resume(thread);
-	    if(kern_result != KERN_SUCCESS) continue;
-	  } 
+	    if(kern_result != KERN_SUCCESS)
+	      ABORT("thread_resume failed");
+	  }
 	}
       }
-	  
-	  mach_port_deallocate(my_task, thread);
+      mach_port_deallocate(my_task, thread);
     }
-    vm_deallocate(my_task, (vm_address_t)act_list, sizeof(thread_t) * listcount);
-	
-	mach_port_deallocate(my_task, my_thread);
+    vm_deallocate(my_task, (vm_address_t)act_list,
+		  sizeof(thread_t) * listcount);
+
+    mach_port_deallocate(my_task, my_thread);
 #   if DEBUG_THREADS
-     GC_printf0("World started\n");
+      GC_printf("World started\n");
 #   endif
 }
 
-void GC_darwin_register_mach_handler_thread(mach_port_t thread) {
+void GC_darwin_register_mach_handler_thread(mach_port_t thread)
+{
   GC_mach_handler_thread = thread;
   GC_use_mach_handler_thread = 1;
 }
diff -uNr mono-1.2.6/libgc/include/private/gc_priv.h mono-1.2.6-new/libgc/include/private/gc_priv.h
--- mono-1.2.6/libgc/include/private/gc_priv.h	2007-11-08 17:06:58.000000000 -0500
+++ mono-1.2.6-new/libgc/include/private/gc_priv.h	2007-11-29 17:38:39.000000000 -0500
@@ -367,6 +367,54 @@
 # endif
 
 #if defined(DARWIN)
+#       if defined(POWERPC)
+#               if CPP_WORDSZ == 32
+#                 define GC_THREAD_STATE_T ppc_thread_state_t
+#                 define GC_MACH_THREAD_STATE PPC_THREAD_STATE
+#                 define GC_MACH_THREAD_STATE_COUNT PPC_THREAD_STATE_COUNT
+#                 define GC_MACH_HEADER mach_header
+#                 define GC_MACH_SECTION section
+#               else
+#                 define GC_THREAD_STATE_T ppc_thread_state64_t
+#                 define GC_MACH_THREAD_STATE PPC_THREAD_STATE64
+#                 define GC_MACH_THREAD_STATE_COUNT PPC_THREAD_STATE64_COUNT
+#                 define GC_MACH_HEADER mach_header_64
+#                 define GC_MACH_SECTION section_64
+#               endif
+#       elif defined(I386) || defined(X86_64)
+#               if CPP_WORDSZ == 32
+#                 define GC_THREAD_STATE_T x86_thread_state32_t
+#                 define GC_MACH_THREAD_STATE x86_THREAD_STATE32
+#                 define GC_MACH_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT
+#                 define GC_MACH_HEADER mach_header
+#                 define GC_MACH_SECTION section
+#               else
+#                 define GC_THREAD_STATE_T x86_thread_state64_t
+#                 define GC_MACH_THREAD_STATE x86_THREAD_STATE64
+#                 define GC_MACH_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT
+#                 define GC_MACH_HEADER mach_header_64
+#                 define GC_MACH_SECTION section_64
+#               endif
+#       else
+#               error define GC_THREAD_STATE_T
+#               define GC_MACH_THREAD_STATE MACHINE_THREAD_STATE
+#               define GC_MACH_THREAD_STATE_COUNT MACHINE_THREAD_STATE_COUNT
+#       endif
+/* Try to work out the right way to access thread state structure members.
+   The structure has changed its definition in different Darwin versions.
+   This now defaults to the (older) names without __, thus hopefully,
+   not breaking any existing Makefile.direct builds.  */
+#       if defined (HAS_PPC_THREAD_STATE___R0) \
+          || defined (HAS_PPC_THREAD_STATE64___R0) \
+          || defined (HAS_X86_THREAD_STATE32___EAX) \
+          || defined (HAS_X86_THREAD_STATE64___RAX)
+#         define THREAD_FLD(x) __ ## x
+#       else
+#         define THREAD_FLD(x) x
+#       endif
+#endif
+
+#if defined(DARWIN)
 #	if defined(POWERPC)
 #		define GC_MACH_THREAD_STATE_FLAVOR PPC_THREAD_STATE
 #	elif defined(I386)
diff -uNr mono-1.2.6/mono/metadata/loader.c mono-1.2.6-new/mono/metadata/loader.c
--- mono-1.2.6/mono/metadata/loader.c	2007-11-08 17:07:19.000000000 -0500
+++ mono-1.2.6-new/mono/metadata/loader.c	2007-11-29 16:22:08.000000000 -0500
@@ -1117,6 +1117,24 @@
 
 		if (!module) {
 			void *iter = NULL;
+			while ((full_name = mono_dl_build_path ("@FINKPREFIX@/lib", file_name, &iter))) {
+				mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,
+					"DllImport loading library: '%s'.", full_name);
+				module = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);
+				if (!module) {
+					mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,
+						"DllImport error loading library '%s'.",
+						error_msg);
+					g_free (error_msg);
+				}
+				g_free (full_name);
+				if (module)
+					break;
+			}
+		}
+
+		if (!module) {
+			void *iter = NULL;
 			while ((full_name = mono_dl_build_path (".", file_name, &iter))) {
 				mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,
 					"DllImport loading library: '%s'.", full_name);
